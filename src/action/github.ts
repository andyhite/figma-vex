/**
 * GitHub API operations for PR and branch management
 */

import * as core from '@actions/core';
import * as exec from '@actions/exec';
import * as github from '@actions/github';
import type { ActionInputs, RepositoryDispatchPayload } from './types.js';

const BRANCH_PREFIX = 'figma-vex/';

/**
 * Configures git with user name and email
 */
async function configureGit(): Promise<void> {
  await exec.exec('git', ['config', '--local', 'user.name', 'github-actions[bot]']);
  await exec.exec('git', [
    'config',
    '--local',
    'user.email',
    'github-actions[bot]@users.noreply.github.com',
  ]);
}

/**
 * Finds an existing open PR with a figma-vex branch
 */
async function findExistingPR(
  octokit: ReturnType<typeof github.getOctokit>,
  owner: string,
  repo: string,
  baseBranch: string
): Promise<{ number: number; head: string } | null> {
  const { data: prs } = await octokit.rest.pulls.list({
    owner,
    repo,
    state: 'open',
    base: baseBranch,
  });

  const existingPR = prs.find((pr) => pr.head.ref.startsWith(BRANCH_PREFIX));
  if (existingPR) {
    return {
      number: existingPR.number,
      head: existingPR.head.ref,
    };
  }

  return null;
}

/**
 * Creates a new branch from the base branch using git
 */
async function createBranch(branchName: string, baseBranch: string): Promise<void> {
  // Fetch the latest from origin
  await exec.exec('git', ['fetch', 'origin', baseBranch]);
  // Create and checkout the new branch
  await exec.exec('git', ['checkout', '-b', branchName, `origin/${baseBranch}`]);
}

/**
 * Checks out an existing branch
 */
async function checkoutBranch(branchName: string): Promise<void> {
  // Fetch the branch from origin
  await exec.exec('git', ['fetch', 'origin', branchName]);

  // Try to checkout the branch (might exist locally)
  const exitCode = await exec.exec('git', ['checkout', branchName], {
    ignoreReturnCode: true,
  });

  // If checkout failed, create a tracking branch
  if (exitCode !== 0) {
    await exec.exec('git', ['checkout', '-b', branchName, `origin/${branchName}`]);
  }
}

/**
 * Commits and pushes changes to a branch using git
 */
async function commitAndPush(
  branch: string,
  commitMessage: string,
  token: string,
  force: boolean
): Promise<void> {
  // Stage all changes
  await exec.exec('git', ['add', '-A']);

  // Check if there are any changes to commit
  const { exitCode, stdout: statusOutput } = await exec.getExecOutput('git', [
    'status',
    '--porcelain',
  ]);
  if (exitCode !== 0) {
    throw new Error('Failed to check git status');
  }
  if (!statusOutput.trim()) {
    core.info('No changes to commit');
    return;
  }

  // Commit changes
  await exec.exec('git', ['commit', '-m', commitMessage]);

  // Configure remote URL with token
  const remoteUrl = `https://${token}@github.com/${github.context.repo.owner}/${github.context.repo.repo}.git`;
  await exec.exec('git', ['remote', 'set-url', 'origin', remoteUrl]);

  // Push changes
  const pushArgs = ['push', 'origin', branch];
  if (force) {
    pushArgs.push('--force');
  }
  await exec.exec('git', pushArgs);
}

/**
 * Creates a PR body with file list and metadata
 */
function createPRBody(payload: RepositoryDispatchPayload, filePaths: string[]): string {
  const { figma_file, generated_at } = payload.client_payload;
  const date = new Date(generated_at).toLocaleString('en-US', {
    dateStyle: 'long',
    timeStyle: 'short',
  });

  const fileList = filePaths.map((path) => `- \`${path}\``).join('\n');

  return `## Figma Variables Update

Updated from **${figma_file}** on ${date}

### Files updated
${fileList}

---
*Auto-generated by [Figma VEX](https://github.com/andyhite/figma-vex)*`;
}

/**
 * Creates or updates a PR
 */
async function createOrUpdatePR(
  octokit: ReturnType<typeof github.getOctokit>,
  owner: string,
  repo: string,
  branch: string,
  baseBranch: string,
  title: string,
  body: string,
  existingPRNumber?: number
): Promise<{ number: number; url: string }> {
  if (existingPRNumber) {
    // Update existing PR
    const { data: pr } = await octokit.rest.pulls.update({
      owner,
      repo,
      pull_number: existingPRNumber,
      body,
    });
    return {
      number: pr.number,
      url: pr.html_url,
    };
  } else {
    // Create new PR
    const { data: pr } = await octokit.rest.pulls.create({
      owner,
      repo,
      title,
      head: branch,
      base: baseBranch,
      body,
    });
    return {
      number: pr.number,
      url: pr.html_url,
    };
  }
}

/**
 * Main function to handle branch and PR operations
 */
export async function handleBranchAndPR(
  inputs: ActionInputs,
  payload: RepositoryDispatchPayload,
  filePaths: string[]
): Promise<{
  prUrl: string;
  prNumber: number;
  branch: string;
  updated: boolean;
}> {
  // Configure git
  await configureGit();

  const octokit = github.getOctokit(inputs.token);
  const { owner, repo } = github.context.repo;
  const baseBranch =
    inputs.baseBranch || github.context.payload.repository?.default_branch || 'main';
  const branchName = `figma-vex/update-${github.context.runId}`;

  // Find existing PR
  const existingPR = await findExistingPR(octokit, owner, repo, baseBranch);
  let branch = branchName;
  let updated = false;

  if (existingPR) {
    // Use existing branch
    branch = existingPR.head;
    updated = true;
    core.info(`Found existing PR #${existingPR.number}, updating branch: ${branch}`);
    await checkoutBranch(branch);
  } else {
    // Create new branch
    core.info(`Creating new branch: ${branch}`);
    await createBranch(branch, baseBranch);
  }

  // Commit and push changes
  core.info(`Committing and pushing changes to ${branch}`);
  await commitAndPush(branch, inputs.prTitle, inputs.token, updated);

  // Create or update PR
  const prBody = createPRBody(payload, filePaths);
  const pr = await createOrUpdatePR(
    octokit,
    owner,
    repo,
    branch,
    baseBranch,
    inputs.prTitle,
    prBody,
    existingPR?.number
  );

  return {
    prUrl: pr.url,
    prNumber: pr.number,
    branch,
    updated,
  };
}
